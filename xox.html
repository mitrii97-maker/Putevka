<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>True Liquid Glass 2025</title>
  <style>
    body, html { margin:0; height:100%; overflow:hidden; background: url('https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=1920') center/cover; }
    canvas { position:absolute; inset:0; width:100%; height:100%; }
    .card {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 380px; height: 500px;
      border-radius: 34px;
      overflow: hidden;
      cursor: move;
    }
    .content {
      position: absolute;
      inset: 40px;
      color: white;
      text-align: center;
      z-index: 2;
      pointer-events: none;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    h1 { font-size: 48px; margin: 0 0 20px; font-weight: 800; }
  </style>
</head>
<body>
  <div class="card">
    <canvas id="glass"></canvas>
    <div class="content">
      <h1>Liquid Glass</h1>
      <p style="font-size:20px; opacity:0.9;">Настоящий iOS 18 / macOS Sequoia<br>на чистом WebGPU 2025</p>
    </div>
  </div>

<script type="module">
if (!navigator.gpu) {
  document.body.innerHTML = "<h1 style='color:white; text-align:center; margin-top:40vh'>WebGPU не поддерживается в твоём браузере :( Открой в Chrome 120+ или Safari 18+</h1>";
}

const canvas = document.getElementById('glass');
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
canvas.width = canvas.clientWidth * devicePixelRatio;
canvas.height = canvas.clientHeight * devicePixelRatio;

const context = canvas.getContext('webgpu');
const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format: presentationFormat, alphaMode: 'premultiplied' });

const shaderCode = `
@vertex
fn vs(@location(0) pos: vec2f) -> @builtin(position) vec4f {
  return vec4f(pos, 0.0, 1.0);
}

@fragment
fn fs(@builtin(position) coord: vec4f) -> @location(0) vec4f {
  let uv = coord.xy / vec2f(${canvas.width}, ${canvas.height});
  let center = vec2f(0.5);
  let dist = length(uv - center);
  let edge = 0.45;
  
  // сильная каустическая рефракция
  var offset = vec2f(
    sin(uv.y * 30.0 + time * 3.0) * 0.02,
    cos(uv.x * 30.0 + time * 3.0) * 0.02
  ) * smoothstep(edge + 0.1, edge, dist);
  
  let refracted = textureSample(backBuffer, sampler, uv + offset * 8.0);
  
  // прозрачность + яркие блики
  let alpha = smoothstep(edge + 0.05, edge - 0.1, dist) * 0.92 + 0.08;
  let highlight = pow(1.0 - dist, 6.0) * 2.5;
  
  return vec4f(refracted.rgb + highlight, alpha);
}
`;

const pipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: { module: device.createShaderModule({ code: shaderCode }), entryPoint: 'vs' },
  fragment: { module: device.createShaderModule({ code: shaderCode.replace('time', '0')), entryPoint: 'fs', targets: [{ format: presentationFormat, blend: { color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha' }, alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha' } } }] },
  primitive: { topology: 'triangle-strip' }
});

let time = 0;
function frame() {
  time += 0.016;
  const commandEncoder = device.createCommandEncoder();
  const textureView = context.getCurrentTexture().createView();
  const renderPass = commandEncoder.beginRenderPass({ colorAttachments: [{ view: textureView, clearValue: { r:0,g:0,b:0,a:0 }, loadOp: 'clear', storeOp: 'store' }] });
  renderPass.setPipeline(pipeline);
  renderPass.draw(4);
  renderPass.end();
  device.queue.submit([commandEncoder.finish()]);
  requestAnimationFrame(frame);
}
frame();
</script>
</body>
</html>