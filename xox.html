<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>–†–∞–±–æ—á–∏–π Liquid Glass 2025</title>
  <style>
    body { margin:0; height:100vh; overflow:hidden; 
      background: url('https://images.unsplash.com/photo-1507525428034-b723cf961d3e?w=1920') center/cover; 
      display:flex; align-items:center; justify-content:center; 
    }
    .card {
      width: 380px; height: 520px;
      border-radius: 36px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 20px 50px rgba(0,0,0,0.4);
    }
    canvas { position:absolute; inset:0; width:100%; height:100%; }
    .content {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      text-align: center;
      padding: 40px;
      pointer-events: none;
      z-index: 10;
      font-family: -apple-system, sans-serif;
    }
    h1 { font-size: 48px; font-weight: 800; margin: 0 0 16px; }
  </style>
</head>
<body>

<div class="card">
  <canvas id="glass"></canvas>
  <div class="content">
    <h1>Liquid Glass</h1>
    <p style="font-size:20px; opacity:0.92;">–¢–µ–ø–µ—Ä—å –≤—Å—ë –≤–∏–¥–Ω–æ üòÖ<br>–ù–∞—Å—Ç–æ—è—â–∏–π —ç—Ñ—Ñ–µ–∫—Ç iOS 18 / macOS Sequoia</p>
  </div>
</div>

<script type="module">
if (!navigator.gpu) {
  alert('WebGPU –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –û—Ç–∫—Ä–æ–π –≤ Chrome 120+, Edge –∏–ª–∏ Safari 18+');
}

const canvas = document.getElementById('glass');
canvas.width = canvas.clientWidth * devicePixelRatio;
canvas.height = canvas.clientHeight * devicePixelRatio;

const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();

const context = canvas.getContext('webgpu');
const format = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format, alphaMode: 'premultiplied' });

// –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º —Ñ–æ–Ω —Å—Ç—Ä–∞–Ω–∏—Ü—ã
const bgLayer = new OffscreenCanvas(canvas.width, canvas.height);
const bgCtx = bgLayer.getContext('2d');
bgCtx.drawImage(document.body, 0, 0, canvas.width, canvas.height);
const bgTexture = device.createTexture({
  size: [canvas.width, canvas.height],
  format: 'rgba8unorm',
  usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST
});
device.queue.copyExternalImageToTexture({ source: bgLayer }, { texture: bgTexture }, [canvas.width, canvas.height]);

const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });

const shader = device.createShaderModule({
  code: `
    @group(0) @binding(0) var bgSampler: sampler;
    @group(0) @binding(1) var bgTexture: texture_2d<f32>;
    @group(0) @binding(2) var<uniform> time: f32;
    @group(0) @binding(3) var<uniform> resolution: vec2<f32>;

    @fragment
    fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
      var uv = pos.xy / resolution;
      let center = vec2<f32>(0.5);
      let dist = length(uv - center);

      // –∫–∞—É—Å—Ç–∏–∫–∏ –ø–æ –∫—Ä–∞—è–º
      let edge = 0.48;
      let strength = 1.0 - smoothstep(edge - 0.1, edge + 0.05, dist);

      // –∂–∏–¥–∫–∞—è —Ä–µ—Ñ—Ä–∞–∫—Ü–∏—è
      let offset = vec2<f32>(
        sin(uv.y * 25.0 + time * 4.0) * 0.015,
        cos(uv.x * 25.0 + time * 4.0) * 0.015
      ) * strength;

      let refractedUV = uv + offset * 12.0;
      var color = textureSample(bgTexture, bgSampler, refractedUV).rgb;

      // —è—Ä–∫–∏–µ —Ä–∞–¥—É–∂–Ω—ã–µ –±–ª–∏–∫–∏
      let highlight = pow(1.0 - dist, 5.0) * 3.0 * strength;
      color += vec3<f32>(highlight * 1.2, highlight * 1.0, highlight * 1.5);

      // –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å (–≤ —Ü–µ–Ω—Ç—Ä–µ –ø–æ—á—Ç–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∑—Ä–∞—á–Ω–æ)
      let alpha = 0.08 + strength * 0.15;

      return vec4<f32>(color, alpha);
    }
  `
});

const pipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: { module: shader, entryPoint: 'vs' }, // –¥–æ–±–∞–≤–∏–º –ø—Ä–æ—Å—Ç–æ–π vs –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
  fragment: { module: shader, entryPoint: 'fs', targets: [{ format, blend: { color: {}, alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha' } } }] },
  primitive: { topology: 'triangle-strip' }
});

const bindGroup = device.createBindGroup({
  layout: pipeline.getBindGroupLayout(0),
  entries: [
    { binding: 0, resource: sampler },
    { binding: 1, resource: bgTexture.createView() },
    { binding: 2, resource: { buffer: device.createBuffer({ size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST }) } },
    { binding: 3, resource: { buffer: device.createBuffer({ size: 8, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, mappedAtCreation: true, data: new Float32Array([canvas.width, canvas.height]) }) } }
  ]
});

let time = 0;
function render() {
  time += 0.016;
  device.queue.writeBuffer(bindGroup.entries[2].resource.buffer, 0, new Float32Array([time]));

  const commandEncoder = device.createCommandEncoder();
  const view = context.getCurrentTexture().createView();
  const renderPass = commandEncoder.beginRenderPass({
    colorAttachments: [{ view, clearValue: [0,0,0,0], loadOp: 'clear', storeOp: 'store' }]
  });
  renderPass.setPipeline(pipeline);
  renderPass.setBindGroup(0, bindGroup);
  renderPass.draw(4);
  renderPass.end();
  device.queue.submit([commandEncoder.finish()]);
  requestAnimationFrame(render);
}
render();
</script>
<script>
// –ü—Ä–æ—Å—Ç–µ–π—à–∏–π vertex shader (–∏–Ω–∞—á–µ –æ—à–∏–±–∫–∞)
const vs = `
@vertex
fn vs(@location(0) pos: vec2<f32>) -> @builtin(position) vec4<f32> {
  return vec4<f32>(pos, 0.0, 1.0);
}
`;
</script>
</body>
</html>